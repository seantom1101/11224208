# å°ˆæ¡ˆå¯¦æˆ°è§£æï¼šåŸºæ–¼æ·±åº¦å­¸ç¿’å»ºæ§‹å·ç©ç¥ç¶“ç¶²è·¯æ¨¡å‹æ¼”ç®—æ³•ï¼Œå¯¦ç¾åœ–åƒè¾¨è­˜åˆ†é¡
11224208 å¼µæ‰¿å‡

## ğŸ“‹ ç›®éŒ„

- [å‰è¨€]
- [åŸºç¤çŸ¥è­˜ä»‹ç´¹]
- [æ•¸æ“šé›†æ”¶é›†]
- [æ¨¡å‹è¨“ç·´]
- [åœ–åƒè¾¨è­˜åˆ†é¡]
- [çµæœå±•ç¤º]
- [ç¸½çµ]
  
---

## å‰è¨€

éš¨è‘—äººå·¥æ™ºæ…§çš„ä¸æ–·ç™¼å±•ï¼Œæ·±åº¦å­¸ç¿’é€™é–€æŠ€è¡“ä¹Ÿè¶Šä¾†è¶Šé‡è¦ï¼Œè¨±å¤šäººé–‹å•Ÿäº†å­¸ç¿’æ©Ÿå™¨å­¸ç¿’ã€‚æœ¬å°ˆæ¡ˆé€éå¯¦æˆ°æ¡ˆä¾‹ï¼Œå¸¶é ˜å¤§å®¶å¾é›¶é–‹å§‹è¨­è¨ˆå¯¦ç¾ä¸€æ¬¾åŸºæ–¼æ·±åº¦å­¸ç¿’çš„åœ–åƒè¾¨è­˜æ¼”ç®—æ³•ã€‚

**å­¸ç¿’æœ¬è¨ˆç•«å…§å®¹ï¼Œä½ éœ€è¦æŒæ¡ä»¥ä¸‹åŸºç¤çŸ¥è­˜ï¼š**

1. Python åŸºç¤èªæ³•
2. è¨ˆç®—æ©Ÿè¦–è¦ºåº« (OpenCV)
3. æ·±åº¦å­¸ç¿’æ¡†æ¶ (TensorFlow)
4. å·ç©ç¥ç¶“ç¶²è·¯ (CNN)

---

## åŸºç¤çŸ¥è­˜ä»‹ç´¹

### 1. Python
Python æ˜¯ä¸€å€‹é«˜å±¤æ¬¡çš„çµåˆäº†è§£é‡‹æ€§ã€ç·¨è­¯æ€§ã€äº’å‹•æ€§å’Œç‰©ä»¶å°å‘çš„è…³æœ¬èªè¨€ã€‚
- å­¸ç¿’é€£çµï¼š[Pythonå­¸ç¿’](https://www.runoob.com/python3/python3-intro.html)

### 2. OpenCV
OpenCV æ˜¯ä¸€å€‹é–‹æºçš„è·¨å¹³å°è¨ˆç®—æ©Ÿè¦–è¦ºåº«ï¼Œå¯¦ç¾äº†åœ–åƒè™•ç†å’Œè¨ˆç®—æ©Ÿè¦–è¦ºæ–¹é¢çš„è¨±å¤šé€šç”¨æ¼”ç®—æ³•ã€‚
- å­¸ç¿’é€£çµï¼š[OpenCVå­¸ç¿’](https://docs.opencv.org/4.x/index.html)

### 3. TensorFlow
TensorFlow æ˜¯Googleé–‹æºçš„è¨ˆç®—æ¡†æ¶ï¼Œå¯ä»¥å¾ˆå¥½åœ°æ”¯æ´æ·±åº¦å­¸ç¿’çš„å„ç¨®æ¼”ç®—æ³•ã€‚
- å­¸ç¿’é€£çµï¼š[TensorFlowå­¸ç¿’](https://tensorflow.google.cn/)

### 4. CNN (å·ç©ç¥ç¶“ç¶²è·¯)
å·ç©ç¥ç¶“ç¶²è·¯æ˜¯ä¸€é¡åŒ…å«å·ç©è¨ˆç®—ä¸”å…·æœ‰æ·±åº¦çµæ§‹çš„å‰é¥‹ç¥ç¶“ç¶²è·¯ï¼Œæ˜¯æ·±åº¦å­¸ç¿’çš„ä»£è¡¨æ€§æ¼”ç®—æ³•ä¹‹ä¸€ã€‚
- å­¸ç¿’é€£çµï¼š[CNNå­¸ç¿’](https://xie.infoq.cn/article/c4d846096c92c7dfcd6539075)

---

## æ•¸æ“šé›†æ”¶é›†
åœ¨é€²è¡Œå½±åƒè¾¨è­˜å‰ï¼Œé¦–å…ˆéœ€è¦æ”¶é›†è³‡æ–™é›†ï¼Œå…¶æ¬¡å°æ–¼è³‡æ–™é›†åšé è™•ç†ï¼Œç„¶å¾Œæ‰èƒ½é€šé
æ·±åº¦å·ç©ç¥ç¶“ç¶²è·¯ä¾†é€²è¡Œç‰¹å¾µå­¸ç¿’ï¼Œå¾—åˆ°ä¼°è¨ˆåˆ†é¡æ¨¡å‹ã€‚å°æ–¼è³‡æ–™é›†çš„è¦æ±‚ï¼Œåœ¨å·ç©ç¥ç¶“ç¶²çµ¡
ï¼ˆCNNï¼‰ä¸­ï¼Œç”±æ–¼å°è¼¸å…¥å½±åƒå‘é‡çš„æ¬Šå€¼åƒæ•¸çš„æ•¸é‡æ˜¯å›ºå®šçš„ï¼Œæ‰€ä»¥åœ¨ç”¨å·ç©ç¶²è·¯ï¼ˆCNNï¼‰å°è³‡æ–™é›†
é€²è¡Œæ¨¡å‹è¨“ç·´å‰éœ€é€²è¡Œå½±åƒé è™•ç†ï¼Œç¢ºä¿è¼¸å…¥çš„å½±åƒå°ºå¯¸æ˜¯å›ºå®šä¸€è‡´çš„ã€‚
<img width="536" height="45" alt="JP9DRjfC7CRtFiN8c_TjfLoWYoezGqym0WUiWeriqoexe8JmGJ2qV11IIg1feOiOAcXYWms7wVndFAjUeKFSIjvPZsT-puVcrBImOUMp6Ua_n8kNK5qX-PLfvhDA4YLLd39m5bddEUK5IcImQSg8Tw_3vP8E7dxxJN47LkDmsIF1WNKNT31djIeRbUbc1_K5tEp3vJrTztXX1AuBzfBileR" src="https://github.com/user-attachments/assets/eda0a3d3-0177-407f-871c-5431b6ab403a" />
åœ–ä¸€ åˆ†é¡ç¶²è·¯æ¨¡å‹æµç¨‹åœ–

# ç¨‹å¼

**åŒ¯å…¥å¥—ä»¶**
```python
import os
import cv2
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import tensorflow as tf

from sklearn.model_selection import train_test_split
from tensorflow.keras import Input, Model
from tensorflow.keras.layers import (
    Conv2D, MaxPooling2D, Dense, Dropout,
    BatchNormalization, GlobalAveragePooling2D
)
from tensorflow.keras.utils import to_categorical

print(f"TensorFlow Version: {tf.__version__}")
```



---

**å®šç¾©æ ¸å¿ƒé¡åˆ¥**
```python
class SafeImageClassifier:
    def __init__(self, image_path, img_size=200):
        self.image_path = image_path
        self.img_size = img_size

        # 1. å–å¾—æ‰€æœ‰è³‡æ–™å¤¾åç¨±
        all_dirs = [
            d for d in os.listdir(image_path)
            if os.path.isdir(os.path.join(image_path, d))
        ]

        # 2. éæ¿¾æ‰ç³»çµ±æª”èˆ‡é æ¸¬ç”¨çš„è³‡æ–™å¤¾
        self.classes = sorted([
            d for d in all_dirs
            if not d.startswith('.') and d != "predictPic"
        ])

        self.class_map = {c: i for i, c in enumerate(self.classes)}
        self.model = None
        self.df = None

        print(f"âœ… åµæ¸¬åˆ°çš„è¨“ç·´é¡åˆ¥: {self.classes}")
        if "predictPic" in all_dirs:
            print("â„¹ï¸ å·²è‡ªå‹•å¿½ç•¥ 'predictPic' è³‡æ–™å¤¾ï¼Œä¸å°‡å…¶è¦–ç‚ºè¨“ç·´é¡åˆ¥ã€‚")

    def resize_images(self):
        print("ğŸ”„ é–‹å§‹èª¿æ•´åœ–ç‰‡å¤§å°...")
        for cls in self.classes:
            cls_folder = os.path.join(self.image_path, cls)
            for f in os.listdir(cls_folder):
                if f.startswith('.'): continue
                fp = os.path.join(cls_folder, f)
                try:
                    img = cv2.imread(fp)
                    if img is not None:
                        img = cv2.resize(img, (self.img_size, self.img_size))
                        cv2.imwrite(fp, img)
                except:
                    pass
        print("âœ… åœ–ç‰‡ Resize å®Œæˆ")

    def generate_csv(self):
        data = []
        for cls in self.classes:
            cls_folder = os.path.join(self.image_path, cls)
            for f in os.listdir(cls_folder):
                if f.startswith('.'): continue
                data.append({
                    "path": os.path.join(cls_folder, f),
                    "label": self.class_map[cls]
                })
        self.df = pd.DataFrame(data)
        # é€™è£¡ä¸å­˜æª”ä¹Ÿæ²’é—œä¿‚ï¼Œç›´æ¥å­˜åœ¨è¨˜æ†¶é«”ä¸­
        print(f"âœ… è³‡æ–™ç´¢å¼•å»ºç«‹å®Œæˆï¼Œå…±æœ‰ {len(self.df)} å¼µåœ–ç‰‡")

    def build_model(self):
        inputs = Input(shape=(self.img_size, self.img_size, 3))

        # ç¬¬ä¸€å±¤
        x = Conv2D(64, 3, activation='relu', padding='same')(inputs)
        x = MaxPooling2D()(x)
        x = BatchNormalization()(x)

        # ç¬¬äºŒå±¤
        x = Conv2D(64, 3, activation='relu', padding='same')(x)
        x = MaxPooling2D()(x)
        x = BatchNormalization()(x)

        # ç¬¬ä¸‰å±¤
        x = Conv2D(32, 3, activation='relu', padding='same')(x)
        x = MaxPooling2D()(x)
        x = BatchNormalization()(x)

        x = GlobalAveragePooling2D()(x)
        x = Dense(128, activation='relu')(x)
        x = Dropout(0.5)(x)

        outputs = Dense(len(self.classes), activation='softmax')(x)

        self.model = Model(inputs, outputs)
        self.model.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['accuracy'])
        print("âœ… æ¨¡å‹å»ºæ§‹å®Œæˆ")

    def train(self, epochs=10, batch_size=2):
        if self.df is None or len(self.df) == 0:
            print("âŒ ç„¡åœ–ç‰‡è³‡æ–™å¯è¨“ç·´")
            return

        X, y = [], []
        for _, row in self.df.iterrows():
            try:
                img = cv2.imread(row['path'])
                if img is not None:
                    img = cv2.resize(img, (self.img_size, self.img_size))
                    img = img / 255.0
                    X.append(img)
                    y.append(row['label'])
            except:
                pass

        X = np.array(X)
        y = to_categorical(y, num_classes=len(self.classes))

        Xtr, Xva, ytr, yva = train_test_split(X, y, test_size=0.2, random_state=42)
        print(f"ğŸš€ é–‹å§‹è¨“ç·´ï¼šè¨“ç·´é›† {len(Xtr)} å¼µ, é©—è­‰é›† {len(Xva)} å¼µ")

        self.model.fit(Xtr, ytr, validation_data=(Xva, yva), epochs=epochs, batch_size=batch_size)

    def predict_image(self, img_path, name_map=None):
        if self.model is None:
            print("âŒ æ¨¡å‹å°šæœªè¨“ç·´")
            return

        img = cv2.imread(img_path)
        if img is None:
            print(f"âŒ æ‰¾ä¸åˆ°åœ–ç‰‡: {img_path}")
            return

        img_display = cv2.cvtColor(img.copy(), cv2.COLOR_BGR2RGB)
        img = cv2.resize(img, (self.img_size, self.img_size))
        img = img / 255.0
        img = np.expand_dims(img, 0)

        probs = self.model.predict(img)[0]
        idx = np.argmax(probs)
        cls = self.classes[idx]
        conf = float(probs[idx])

        label_show = name_map.get(cls, cls) if name_map else cls

        plt.figure(figsize=(4,4))
        plt.imshow(img_display)
        plt.title(f"{label_show} ({conf:.1%})")
        plt.axis('off')
        plt.show()

        return cls, conf
```
---

**åˆå§‹åŒ–èˆ‡è¨“ç·´ (Training)**
```python
# è¨­å®šä½ çš„åœ–ç‰‡è³‡æ–™å¤¾è·¯å¾‘
PATH = "/content/drive/MyDrive/picture/"

# 1. åˆå§‹åŒ–
classifier = SafeImageClassifier(PATH)

# 2. è™•ç†åœ–ç‰‡èˆ‡å»ºç«‹ç´¢å¼•
classifier.resize_images()
classifier.generate_csv()

# 3. å»ºç«‹æ¨¡å‹ (å·²åŒ…å«æ›´å¤šæ•¸æ“šå¢å¼·)
classifier.build_model()

# 4. é€²è¡Œåˆæ­¥è¨“ç·´
print("\n--- éšæ®µä¸€ï¼šåˆæ­¥è¨“ç·´ (å‡çµåŸºåº•æ¨¡å‹) ---")
classifier.train(epochs=20, batch_size=32)
```

---

**é æ¸¬ (Prediction)**
```python
# è¨­å®šä½ è¦é æ¸¬çš„åœ–ç‰‡è·¯å¾‘
test_img = "/content/drive/MyDrive/picture/cat/000001.jpg"

# è¨­å®šä¸­æ–‡é¡¯ç¤ºå°ç…§è¡¨ (å¯é¸)
my_map = {
    "bird": "Bird (é³¥)",
    "cat": "Cat (è²“)"
}

# åŸ·è¡Œé æ¸¬
if os.path.exists(test_img):
    result, confidence = classifier.predict_image(test_img, name_map=my_map)
    print(f"é æ¸¬çµæœ: {result}, ä¿¡å¿ƒåº¦: {confidence:.4f}")
else:
    print(f"æ‰¾ä¸åˆ°æ¸¬è©¦åœ–ç‰‡ï¼Œè«‹æª¢æŸ¥è·¯å¾‘: {test_img}")
```

---

<img width="453" height="155" alt="image" src="https://github.com/user-attachments/assets/f75ebcc2-5083-4524-ad92-3b4794dc4fc9" />


**å»ºç«‹åˆ†é¡å™¨:**

        classifier = SafeImageClassifier(image_path)

image_path æ˜¯è³‡æ–™é›†æ ¹ç›®éŒ„ã€‚æœƒè‡ªå‹•æƒæè³‡æ–™å¤¾ï¼Œå°‡æ¯å€‹å­è³‡æ–™å¤¾è¦–ç‚ºä¸€å€‹é¡åˆ¥ã€‚åˆå§‹åŒ–æ™‚æœƒåˆ—å‡ºé¡åˆ¥åç¨±ã€‚

**åœ–ç‰‡è™•ç†:**

        classifier.resize_images()
        
å°‡æ¯å€‹é¡åˆ¥è³‡æ–™å¤¾ä¸­çš„åœ–ç‰‡ resize æˆå›ºå®šå¤§å°ï¼ˆ200Ã—200ï¼‰ã€‚

é¿å…è¨“ç·´æ™‚å› ç‚ºå°ºå¯¸ä¸åŒé€ æˆéŒ¯èª¤ã€‚
        
        classifier.generate_csv()

ç”Ÿæˆ CSVï¼Œè¨˜éŒ„æ¯å¼µåœ–ç‰‡è·¯å¾‘èˆ‡å°æ‡‰æ¨™ç±¤ã€‚

CSV æ–¹ä¾¿å¾ŒçºŒè®€å–è¨“ç·´è³‡æ–™ã€‚


---

# çµæœåœ–




